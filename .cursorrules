# Next.js App Router - Immutable Architecture Laws

You are a senior Next.js engineer with expertise in the App Router (version 13+). Follow these immutable laws when writing or reviewing code.

## 1. Server Components by Default
- ALWAYS use Server Components unless client interactivity is required
- Mark components with "use client" only when necessary
- Never use "use client" at the page.tsx level

## 2. Co-location is King
- Place components, styles, tests, and utilities in the same directory
- Follow this structure:
  ```
  app/
    (group)/
      route/
        page.tsx
        layout.tsx
        components/
          server-component.tsx
          client-component.tsx
        utils/
          data-fetching.ts
        __tests__/
          page.test.tsx
  ```

## 3. File-based Routing is Sacred
- NEVER create custom routing logic
- Use Next.js conventions: page.tsx, layout.tsx, loading.tsx, error.tsx
- Dynamic routes: [param], [...slug], [[...optional]]

## 4. Data Fetching Follows Gravity
- Fetch data at the highest server component level
- Pass data down as props to child components
- Use server actions for mutations
- Cache aggressively with `fetch()` options

## 5. Client-Server Boundary is Explicit
- Keep "use client" directive as close to the leaves as possible
- Extract client logic into the smallest possible components
- Pass server data to client components via props

## 6. Progressive Enhancement Always
- Components must work without JavaScript
- Client features should enhance, not replace, server functionality
- Test with JavaScript disabled

## 7. Route Groups for Organization
- Use (folder) syntax for logical grouping
- Common patterns: (marketing), (app), (auth), (admin)
- Share layouts within groups

## 8. Loading and Error States are First-class
- ALWAYS provide loading.tsx for async operations
- ALWAYS provide error.tsx for error boundaries
- Use Suspense for granular loading states

## 9. Metadata is Declarative
- Export metadata object or generateMetadata function
- Never manipulate head tags directly
- Use built-in metadata types

## 10. Performance is Architecture
- Minimize client bundle size
- Use dynamic imports for code splitting
- Implement proper caching strategies
- Parallel data fetching where possible

## Decision Framework

When creating new functionality, follow this decision tree:

### 1. Request Classification
- Bug fix: Update existing code
- Enhancement: Extend existing feature
- New feature: Create new components/routes

### 2. Code Reuse Decision
```
Does similar functionality exist?
├─ YES
│  ├─ Is it in the same route?
│  │  ├─ YES → Extend local component
│  │  └─ NO → Is it used in 3+ places?
│  │     ├─ YES → Move to shared components
│  │     └─ NO → Duplicate and specialize
│  └─ Consider composition over inheritance
└─ NO → Create new component
```

### 3. Component Type Decision
```
Does it need interactivity/browser APIs?
├─ YES → Create client component ("use client")
│  └─ Can server component wrap it?
│     ├─ YES → Create wrapper pattern
│     └─ NO → Keep as client component
└─ NO → Keep as server component
```

### 4. File Placement Rules
1. Route-specific → `/app/(group)/route/components/`
2. Group-shared → `/app/(group)/_components/`
3. App-shared → `/app/_components/`
4. Utilities → `/lib/` or `/utils/`

## Code Quality Requirements
- TypeScript strict mode enabled
- Proper error boundaries
- Accessibility standards met
- Performance metrics tracked
- Unit tests for utilities
- Integration tests for routes

## State Management Hierarchy
1. URL state (searchParams)
2. Server state (database)
3. Local component state
4. Context (sparingly)
5. Global store (last resort)

## TypeScript Immutable Laws

1. **Strict Configuration Mandatory** - Enable all strict flags
2. **No Any** - Use `unknown` for truly unknown types
3. **Explicit Types** - Type all function parameters and returns
4. **Discriminated Unions** - Model complex state properly
5. **Readonly by Default** - Use `as const` and `readonly`
6. **Type Guards Required** - Runtime validation for external data
7. **Result Types** - Error handling with type safety
8. **Named Exports Only** - Better refactoring support
9. **Exhaustive Checks** - Handle all union cases
10. **Component Props Typed** - Full type safety for React

## File Extensions
- `.tsx` = Contains JSX elements
- `.ts` = Pure TypeScript (no JSX)