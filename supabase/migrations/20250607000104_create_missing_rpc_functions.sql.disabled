-- Create missing RPC functions that the code expects

-- 1. search_all_lodges - Already has fallback in code, but let's create it for performance
CREATE OR REPLACE FUNCTION public.search_all_lodges(
    search_term text,
    result_limit integer DEFAULT 10
) RETURNS TABLE (
    lodge_id uuid,
    organisation_id uuid,
    grand_lodge_id uuid,
    name text,
    number integer,
    display_name text,
    district text,
    meeting_place text,
    meeting_day text,
    meeting_time text,
    created_at timestamptz,
    updated_at timestamptz
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        l.lodge_id,
        l.organisation_id,
        l.grand_lodge_id,
        l.name,
        l.number,
        l.display_name,
        l.district,
        l.meeting_place,
        l.meeting_day,
        l.meeting_time,
        l.created_at,
        l.updated_at
    FROM lodges l
    WHERE 
        l.name ILIKE '%' || search_term || '%' OR
        l.display_name ILIKE '%' || search_term || '%' OR
        l.district ILIKE '%' || search_term || '%' OR
        l.meeting_place ILIKE '%' || search_term || '%' OR
        (l.number IS NOT NULL AND l.number::text = search_term)
    ORDER BY 
        -- Exact number match first
        CASE WHEN l.number::text = search_term THEN 0 ELSE 1 END,
        -- Then by name
        l.display_name
    LIMIT result_limit;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.search_all_lodges(text, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.search_all_lodges(text, integer) TO anon;

-- 2. get_ticket_availability - Wrapper around check_ticket_availability for compatibility
CREATE OR REPLACE FUNCTION public.get_ticket_availability(
    p_event_id uuid
) RETURNS TABLE (
    event_ticket_id uuid,
    ticket_type text,
    price numeric,
    total_capacity integer,
    sold_count integer,
    reserved_count integer,
    available_count integer
) AS $$
BEGIN
    -- Delegate to existing check_ticket_availability function
    RETURN QUERY
    SELECT * FROM public.check_ticket_availability(p_event_id);
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_ticket_availability(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_ticket_availability(uuid) TO anon;

-- 3. create_function_registration - Comprehensive registration creation
CREATE OR REPLACE FUNCTION public.create_function_registration(
    p_function_id uuid,
    p_customer_id uuid,
    p_registration_type registration_type,
    p_registration_data jsonb
) RETURNS jsonb AS $$
DECLARE
    v_registration_id uuid;
    v_result jsonb;
BEGIN
    -- Generate new registration ID
    v_registration_id := gen_random_uuid();
    
    -- Create registration based on type
    CASE p_registration_type
        WHEN 'individuals' THEN
            -- Prepare data for individual registration
            v_result := public.upsert_individual_registration(
                jsonb_build_object(
                    'registrationId', v_registration_id,
                    'authUserId', p_customer_id,
                    'functionId', p_function_id
                ) || p_registration_data
            );
            
        WHEN 'lodge' THEN
            -- Extract lodge registration parameters
            v_result := public.upsert_lodge_registration(
                p_function_id,
                (p_registration_data->>'packageId')::uuid,
                (p_registration_data->>'tableCount')::integer,
                p_registration_data->'bookingContact',
                p_registration_data->'lodgeDetails'
            );
            
        WHEN 'delegation' THEN
            -- Delegate to delegation registration
            v_result := public.upsert_delegation_registration(
                p_registration_data || jsonb_build_object(
                    'registrationId', v_registration_id,
                    'authUserId', p_customer_id,
                    'functionId', p_function_id
                )
            );
            
        ELSE
            RAISE EXCEPTION 'Unsupported registration type: %', p_registration_type;
    END CASE;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.create_function_registration(uuid, uuid, registration_type, jsonb) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_function_registration(uuid, uuid, registration_type, jsonb) TO anon;

-- 4. get_payment_processing_data - Get data needed for payment processing
CREATE OR REPLACE FUNCTION public.get_payment_processing_data(
    p_registration_id uuid
) RETURNS jsonb AS $$
DECLARE
    v_result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'registration', row_to_json(r.*),
        'customer', row_to_json(c.*),
        'function', row_to_json(f.*),
        'attendees', COALESCE(
            (SELECT jsonb_agg(row_to_json(a.*))
             FROM attendees a
             WHERE a.registration_id = p_registration_id),
            '[]'::jsonb
        ),
        'tickets', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'ticket_id', t.ticket_id,
                    'event_id', t.event_id,
                    'attendee_id', t.attendee_id,
                    'price_paid', t.price_paid,
                    'status', t.status,
                    'event_title', e.title,
                    'ticket_type', et.name
                )
             )
             FROM tickets t
             JOIN events e ON t.event_id = e.event_id
             LEFT JOIN event_tickets et ON t.event_ticket_id = et.event_ticket_id
             WHERE t.registration_id = p_registration_id),
            '[]'::jsonb
        )
    ) INTO v_result
    FROM registrations r
    JOIN customers c ON r.customer_id = c.customer_id
    JOIN functions f ON r.function_id = f.function_id
    WHERE r.registration_id = p_registration_id;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_payment_processing_data(uuid) TO authenticated;

-- 5. release_registration_tickets - Release tickets when registration is cancelled
CREATE OR REPLACE FUNCTION public.release_registration_tickets(
    p_registration_id uuid
) RETURNS jsonb AS $$
DECLARE
    v_released_count integer;
BEGIN
    -- Update ticket status to 'cancelled' or delete them
    UPDATE tickets
    SET 
        status = 'cancelled',
        updated_at = CURRENT_TIMESTAMP
    WHERE 
        registration_id = p_registration_id
        AND status IN ('pending', 'reserved', 'sold');
        
    GET DIAGNOSTICS v_released_count = ROW_COUNT;
    
    -- Update registration status
    UPDATE registrations
    SET 
        status = 'cancelled',
        updated_at = CURRENT_TIMESTAMP
    WHERE registration_id = p_registration_id;
    
    RETURN jsonb_build_object(
        'success', true,
        'releasedTickets', v_released_count,
        'registrationId', p_registration_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.release_registration_tickets(uuid) TO authenticated;

-- 6. get_package_availability - Check package availability
CREATE OR REPLACE FUNCTION public.get_package_availability(
    p_package_id uuid
) RETURNS jsonb AS $$
DECLARE
    v_package record;
    v_sold_count integer;
    v_available boolean;
    v_available_count integer;
BEGIN
    -- Get package details
    SELECT * INTO v_package
    FROM packages
    WHERE package_id = p_package_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'error', 'Package not found',
            'packageId', p_package_id
        );
    END IF;
    
    -- Count sold packages (based on registrations)
    SELECT COUNT(*) INTO v_sold_count
    FROM registrations r
    WHERE r.registration_data->>'packageId' = p_package_id::text
    AND r.payment_status IN ('completed', 'pending')
    AND r.status != 'cancelled';
    
    -- Calculate availability
    IF v_package.max_quantity IS NULL THEN
        v_available := true;
        v_available_count := NULL; -- Unlimited
    ELSE
        v_available_count := v_package.max_quantity - v_sold_count;
        v_available := v_available_count > 0;
    END IF;
    
    RETURN jsonb_build_object(
        'packageId', p_package_id,
        'packageName', v_package.name,
        'maxQuantity', v_package.max_quantity,
        'soldCount', v_sold_count,
        'availableCount', v_available_count,
        'isAvailable', v_available,
        'price', v_package.package_price
    );
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_package_availability(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_package_availability(uuid) TO anon;

-- 7. update_package_capacity - Update package capacity
CREATE OR REPLACE FUNCTION public.update_package_capacity(
    p_package_id uuid,
    p_new_capacity integer
) RETURNS jsonb AS $$
BEGIN
    UPDATE packages
    SET 
        max_quantity = p_new_capacity,
        updated_at = CURRENT_TIMESTAMP
    WHERE package_id = p_package_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Package not found'
        );
    END IF;
    
    RETURN jsonb_build_object(
        'success', true,
        'packageId', p_package_id,
        'newCapacity', p_new_capacity
    );
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.update_package_capacity(uuid, integer) TO authenticated;

-- 8. get_function_eligible_tickets - Get tickets eligible for a function
CREATE OR REPLACE FUNCTION public.get_function_eligible_tickets(
    p_function_id uuid,
    p_attendee_type text DEFAULT NULL
) RETURNS TABLE (
    event_id uuid,
    event_title text,
    event_start timestamptz,
    ticket_id uuid,
    ticket_name text,
    ticket_price numeric,
    eligibility_criteria jsonb
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.event_id,
        e.title as event_title,
        e.event_start,
        et.event_ticket_id as ticket_id,
        et.name as ticket_name,
        et.price as ticket_price,
        et.eligibility_criteria
    FROM events e
    JOIN event_tickets et ON e.event_id = et.event_id
    WHERE e.function_id = p_function_id
    AND e.is_published = true
    AND (
        p_attendee_type IS NULL OR
        et.eligibility_criteria IS NULL OR
        et.eligibility_criteria->>'attendeeType' = p_attendee_type OR
        NOT (et.eligibility_criteria ? 'attendeeType')
    )
    ORDER BY e.event_start, et.display_order, et.name;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_function_eligible_tickets(uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_function_eligible_tickets(uuid, text) TO anon;