-- Create individuals_registered view for confirmation page display
CREATE OR REPLACE VIEW public.individuals_registered_view AS
SELECT 
  r.registration_id,
  r.confirmation_number,
  r.registration_date,
  r.payment_status,
  r.total_amount_paid,
  r.total_price_paid,
  r.stripe_fee,
  r.subtotal,
  r.includes_processing_fee,
  r.stripe_payment_intent_id,
  
  -- Booking contact details
  bc.first_name as booking_first_name,
  bc.last_name as booking_last_name,
  bc.email as booking_email,
  bc.mobile_number as booking_phone,
  bc.billing_street_address,
  bc.billing_city,
  bc.billing_state,
  bc.billing_postal_code,
  bc.billing_country,
  bc.billing_organisation_name,
  
  -- Function details
  f.function_id,
  f.name as function_name,
  f.slug as function_slug,
  f.start_date as function_start_date,
  f.end_date as function_end_date,
  
  -- Attendees array with full details
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        'attendee_id', a.attendee_id,
        'full_name', CONCAT(ac.first_name, ' ', ac.last_name),
        'first_name', ac.first_name,
        'last_name', ac.last_name,
        'email', ac.email,
        'phone', ac.mobile_number,
        'attendee_type', a.attendee_type,
        'is_primary', a.is_primary,
        'has_partner', a.has_partner,
        'is_partner', a.is_partner,
        'title', ac.title,
        'suffix', a.suffix,
        'dietary_requirements', a.dietary_requirements,
        'special_needs', a.special_needs,
        'contact_preference', a.contact_preference,
        'masonic_profile', CASE 
          WHEN mp.masonic_profile_id IS NOT NULL THEN 
            jsonb_build_object(
              'masonic_title', mp.masonic_title,
              'rank', mp.rank,
              'grand_rank', mp.grand_rank,
              'grand_officer', mp.grand_officer,
              'grand_office', mp.grand_office,
              'lodge_name', l.name,
              'lodge_number', l.number,
              'grand_lodge_name', gl.name
            )
          ELSE NULL
        END,
        'tickets', (
          SELECT json_agg(
            jsonb_build_object(
              'ticket_id', t.ticket_id,
              'event_name', e.title,
              'event_date', e.event_start,
              'price_paid', t.price_paid,
              'original_price', t.original_price,
              'qr_code_url', t.qr_code_url,
              'ticket_status', t.ticket_status,
              'status', t.status
            )
          )
          FROM tickets t
          JOIN events e ON t.event_id = e.event_id
          WHERE t.attendee_id = a.attendee_id
        )
      )
    ) FILTER (WHERE a.attendee_id IS NOT NULL),
    '[]'::json
  ) as attendees,
  
  -- Total counts
  COUNT(DISTINCT a.attendee_id) as total_attendees,
  COUNT(DISTINCT t.ticket_id) as total_tickets
  
FROM registrations r
LEFT JOIN contacts bc ON r.contact_id = bc.contact_id
LEFT JOIN functions f ON r.function_id = f.function_id
LEFT JOIN attendees a ON r.registration_id = a.registration_id
LEFT JOIN contacts ac ON a.contact_id = ac.contact_id
LEFT JOIN masonic_profiles mp ON ac.contact_id = mp.contact_id
LEFT JOIN lodges l ON mp.lodge_id = l.lodge_id
LEFT JOIN grand_lodges gl ON mp.grand_lodge_id = gl.grand_lodge_id
LEFT JOIN tickets t ON a.attendee_id = t.attendee_id
WHERE r.registration_type = 'individuals'
GROUP BY 
  r.registration_id,
  bc.contact_id,
  f.function_id;

-- Grant appropriate permissions
GRANT SELECT ON public.individuals_registered_view TO authenticated;
GRANT SELECT ON public.individuals_registered_view TO anon;

-- Create RPC function for upserting individual registrations
CREATE OR REPLACE FUNCTION public.upsert_individual_registration(
  p_registration_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_registration_id uuid;
  v_function_id uuid;
  v_primary_attendee_contact_id uuid;
  v_booking_contact_id uuid;
  v_attendee_record jsonb;
  v_created_attendee_id uuid;
  v_ticket_record jsonb;
  v_confirmation_number text;
  v_bill_to_primary boolean;
  v_auth_user_id uuid;
BEGIN
  -- Extract core data
  v_registration_id := COALESCE((p_registration_data->>'registrationId')::uuid, gen_random_uuid());
  v_function_id := (p_registration_data->>'functionId')::uuid;
  v_bill_to_primary := COALESCE((p_registration_data->>'billToPrimaryAttendee')::boolean, false);
  v_auth_user_id := (p_registration_data->>'authUserId')::uuid;
  
  -- Generate confirmation number
  v_confirmation_number := 'FUNC-' || to_char(NOW(), 'YYYYMMDD') || '-' || 
                          substr(v_registration_id::text, 1, 4);

  -- Step 1: Create booking contact if not billing to primary attendee
  IF NOT v_bill_to_primary AND p_registration_data->'billingDetails' IS NOT NULL THEN
    INSERT INTO contacts (
      auth_user_id,
      email,
      first_name,
      last_name,
      mobile_number,
      type,
      billing_email,
      billing_phone,
      billing_street_address,
      billing_city,
      billing_state,
      billing_postal_code,
      billing_country,
      billing_organisation_name,
      address_line_1,
      address_line_2,
      suburb_city,
      state,
      postcode,
      country
    ) VALUES (
      v_auth_user_id,
      p_registration_data->'billingDetails'->>'emailAddress',
      p_registration_data->'billingDetails'->>'firstName',
      p_registration_data->'billingDetails'->>'lastName',
      p_registration_data->'billingDetails'->>'mobileNumber',
      'individual',
      p_registration_data->'billingDetails'->>'emailAddress',
      p_registration_data->'billingDetails'->>'mobileNumber',
      p_registration_data->'billingDetails'->>'addressLine1',
      p_registration_data->'billingDetails'->>'suburb',
      p_registration_data->'billingDetails'->'stateTerritory'->>'name',
      p_registration_data->'billingDetails'->>'postcode',
      p_registration_data->'billingDetails'->'country'->>'name',
      p_registration_data->'billingDetails'->>'businessName',
      p_registration_data->'billingDetails'->>'addressLine1',
      p_registration_data->'billingDetails'->>'addressLine2',
      p_registration_data->'billingDetails'->>'suburb',
      p_registration_data->'billingDetails'->'stateTerritory'->>'name',
      p_registration_data->'billingDetails'->>'postcode',
      p_registration_data->'billingDetails'->'country'->>'name'
    )
    RETURNING contact_id INTO v_booking_contact_id;
  END IF;

  -- Step 2: Process all attendees and create contacts
  FOR v_attendee_record IN 
    SELECT * FROM jsonb_array_elements(
      COALESCE(
        jsonb_build_array(p_registration_data->'primaryAttendee') || 
        COALESCE(p_registration_data->'additionalAttendees', '[]'::jsonb),
        '[]'::jsonb
      )
    )
  LOOP
    DECLARE
      v_contact_id uuid;
      v_is_primary boolean;
      v_attendee_type text;
      v_include_contact_details boolean;
    BEGIN
      v_is_primary := COALESCE((v_attendee_record->>'isPrimary')::boolean, false);
      v_attendee_type := LOWER(COALESCE(v_attendee_record->>'attendeeType', 'guest'));
      
      -- Determine if contact details should be included
      v_include_contact_details := v_is_primary OR 
        LOWER(v_attendee_record->>'contactPreference') = 'directly';
      
      -- Create contact for attendee
      INSERT INTO contacts (
        email,
        first_name,
        last_name,
        mobile_number,
        title,
        type,
        contact_preference,
        dietary_requirements,
        special_needs,
        has_partner,
        is_partner
      ) VALUES (
        CASE WHEN v_include_contact_details THEN v_attendee_record->>'email' END,
        v_attendee_record->>'firstName',
        v_attendee_record->>'lastName',
        CASE WHEN v_include_contact_details THEN v_attendee_record->>'phone' END,
        CASE 
          WHEN v_attendee_type = 'mason' THEN v_attendee_record->>'masonicTitle'
          ELSE v_attendee_record->>'title'
        END,
        'individual',
        LOWER(v_attendee_record->>'contactPreference'),
        v_attendee_record->>'dietaryRequirements',
        v_attendee_record->>'specialNeeds',
        (v_attendee_record->>'hasPartner')::boolean,
        CASE WHEN (v_attendee_record->>'isPartner')::boolean THEN true END
      )
      RETURNING contact_id INTO v_contact_id;
      
      -- If primary attendee and billing to primary, update with billing details and auth_user_id
      IF v_is_primary AND v_bill_to_primary AND p_registration_data->'billingDetails' IS NOT NULL THEN
        v_primary_attendee_contact_id := v_contact_id;
        
        UPDATE contacts SET
          auth_user_id = v_auth_user_id,
          billing_email = p_registration_data->'billingDetails'->>'emailAddress',
          billing_phone = p_registration_data->'billingDetails'->>'mobileNumber',
          billing_street_address = p_registration_data->'billingDetails'->>'addressLine1',
          billing_city = p_registration_data->'billingDetails'->>'suburb',
          billing_state = p_registration_data->'billingDetails'->'stateTerritory'->>'name',
          billing_postal_code = p_registration_data->'billingDetails'->>'postcode',
          billing_country = p_registration_data->'billingDetails'->'country'->>'name',
          billing_organisation_name = p_registration_data->'billingDetails'->>'businessName'
        WHERE contact_id = v_contact_id;
      END IF;
      
      -- Create masonic profile if mason
      IF v_attendee_type = 'mason' THEN
        INSERT INTO masonic_profiles (
          contact_id,
          masonic_title,
          rank,
          grand_rank,
          grand_officer,
          grand_office,
          lodge_id,
          grand_lodge_id
        ) VALUES (
          v_contact_id,
          v_attendee_record->>'masonicTitle',
          v_attendee_record->>'rank',
          v_attendee_record->>'grandRank',
          v_attendee_record->>'grandOfficer',
          v_attendee_record->>'grandOffice',
          (v_attendee_record->>'lodge_id')::uuid,
          (v_attendee_record->>'grand_lodge_id')::uuid
        );
      END IF;
      
      -- Create attendee record
      INSERT INTO attendees (
        attendee_id,
        registration_id,
        contact_id,
        attendee_type,
        first_name,
        last_name,
        email,
        phone,
        title,
        suffix,
        is_primary,
        has_partner,
        is_partner,
        contact_preference,
        dietary_requirements,
        special_needs,
        related_attendee_id
      ) VALUES (
        COALESCE((v_attendee_record->>'attendee_id')::uuid, gen_random_uuid()),
        v_registration_id,
        v_contact_id,
        v_attendee_type,
        v_attendee_record->>'firstName',
        v_attendee_record->>'lastName',
        CASE WHEN v_include_contact_details THEN v_attendee_record->>'email' END,
        CASE WHEN v_include_contact_details THEN v_attendee_record->>'phone' END,
        CASE 
          WHEN v_attendee_type = 'mason' THEN v_attendee_record->>'masonicTitle'
          ELSE v_attendee_record->>'title'
        END,
        CASE 
          WHEN v_attendee_type = 'mason' THEN
            CASE 
              WHEN v_attendee_record->>'rank' = 'GL' THEN v_attendee_record->>'grandRank'
              ELSE v_attendee_record->>'rank'
            END
          ELSE v_attendee_record->>'suffix'
        END,
        v_is_primary,
        (v_attendee_record->>'hasPartner')::boolean,
        CASE WHEN (v_attendee_record->>'isPartner')::boolean THEN 'true' END,
        LOWER(v_attendee_record->>'contactPreference'),
        v_attendee_record->>'dietaryRequirements',
        v_attendee_record->>'specialNeeds',
        (v_attendee_record->>'related_attendee_id')::uuid
      )
      RETURNING attendee_id INTO v_created_attendee_id;
      
      -- Store primary attendee contact ID
      IF v_is_primary AND v_bill_to_primary THEN
        v_primary_attendee_contact_id := v_contact_id;
      END IF;
    END;
  END LOOP;

  -- Step 3: Create or update registration
  -- Check if this is a payment completion update
  DECLARE
    v_is_payment_update boolean := false;
    v_existing_status text;
  BEGIN
    -- Check if registration exists and get its status
    SELECT status INTO v_existing_status
    FROM registrations
    WHERE registration_id = v_registration_id;
    
    -- If we have a payment intent ID and totalAmountPaid > 0, this is a payment completion
    v_is_payment_update := v_existing_status IS NOT NULL AND 
                          (p_registration_data->>'totalAmountPaid')::numeric > 0 AND
                          p_registration_data->>'paymentCompleted' = 'true';
    
    INSERT INTO registrations (
      registration_id,
      function_id,
      contact_id,
      auth_user_id,
      registration_type,
      registration_date,
      status,
      payment_status,
      total_amount_paid,
      total_price_paid,
      subtotal,
      stripe_fee,
      includes_processing_fee,
      confirmation_number,
      stripe_payment_intent_id,
      agree_to_terms,
      registration_data
    ) VALUES (
      v_registration_id,
      v_function_id,
      COALESCE(v_primary_attendee_contact_id, v_booking_contact_id),
      v_auth_user_id,
      'individuals',
      NOW(),
      CASE WHEN v_is_payment_update THEN 'completed' ELSE 'unpaid' END,
      CASE WHEN v_is_payment_update THEN 'completed' ELSE 'pending' END,
      CASE WHEN v_is_payment_update THEN (p_registration_data->>'totalAmountPaid')::numeric ELSE 0 END,
      COALESCE((p_registration_data->>'subtotal')::numeric, 0), -- Order total excluding stripe fee
      COALESCE((p_registration_data->>'subtotal')::numeric, 0),
      COALESCE((p_registration_data->>'stripeFee')::numeric, 0),
      COALESCE((p_registration_data->>'stripeFee')::numeric, 0) > 0,
      v_confirmation_number,
      p_registration_data->>'paymentIntentId',
      COALESCE((p_registration_data->>'agreeToTerms')::boolean, true),
      jsonb_build_array(p_registration_data)
    )
    ON CONFLICT (registration_id) DO UPDATE SET
      contact_id = COALESCE(registrations.contact_id, EXCLUDED.contact_id),
      total_price_paid = CASE WHEN v_is_payment_update THEN EXCLUDED.total_price_paid ELSE registrations.total_price_paid END,
      total_amount_paid = CASE WHEN v_is_payment_update THEN (p_registration_data->>'totalAmountPaid')::numeric ELSE registrations.total_amount_paid END,
      status = CASE WHEN v_is_payment_update THEN 'completed' ELSE registrations.status END,
      payment_status = CASE WHEN v_is_payment_update THEN 'completed' ELSE registrations.payment_status END,
      subtotal = EXCLUDED.subtotal,
      stripe_fee = EXCLUDED.stripe_fee,
      includes_processing_fee = EXCLUDED.includes_processing_fee,
      stripe_payment_intent_id = COALESCE(EXCLUDED.stripe_payment_intent_id, registrations.stripe_payment_intent_id),
      confirmation_number = COALESCE(EXCLUDED.confirmation_number, registrations.confirmation_number),
      updated_at = NOW(),
      registration_data = registrations.registration_data || jsonb_build_array(p_registration_data);
    
    -- If this is a payment update, update ticket statuses
    IF v_is_payment_update THEN
      UPDATE tickets SET
        status = 'sold',
        ticket_status = 'sold',
        payment_status = 'paid',
        purchased_at = NOW(),
        updated_at = NOW()
      WHERE registration_id = v_registration_id
        AND status = 'reserved';
        
      -- Update event ticket counts
      WITH ticket_counts AS (
        SELECT 
          et.event_ticket_id,
          COUNT(*) as sold_count
        FROM tickets t
        JOIN event_tickets et ON t.ticket_type_id = et.event_ticket_id
        WHERE t.registration_id = v_registration_id
          AND t.status = 'sold'
        GROUP BY et.event_ticket_id
      )
      UPDATE event_tickets et
      SET 
        sold_count = COALESCE(et.sold_count, 0) + tc.sold_count,
        reserved_count = GREATEST(0, COALESCE(et.reserved_count, 0) - tc.sold_count),
        available_count = GREATEST(0, et.total_capacity - (COALESCE(et.sold_count, 0) + tc.sold_count))
      FROM ticket_counts tc
      WHERE et.event_ticket_id = tc.event_ticket_id;
    END IF;
  END;

  -- Step 4: Process tickets
  FOR v_ticket_record IN 
    SELECT * FROM jsonb_array_elements(COALESCE(p_registration_data->'tickets', '[]'::jsonb))
  LOOP
    -- Get event ticket price
    DECLARE
      v_event_ticket_price numeric;
      v_attendee_id uuid;
    BEGIN
      -- Get the attendee ID for this ticket
      v_attendee_id := (v_ticket_record->>'attendeeId')::uuid;
      
      -- Get event ticket price
      SELECT price INTO v_event_ticket_price
      FROM event_tickets
      WHERE event_ticket_id = (v_ticket_record->>'ticketTypeId')::uuid;
      
      -- Insert ticket
      INSERT INTO tickets (
        ticket_id,
        attendee_id,
        event_id,
        registration_id,
        ticket_type_id,
        ticket_price,
        original_price,
        price_paid,
        status,
        ticket_status,
        payment_status,
        is_partner_ticket,
        package_id
      )
      SELECT
        COALESCE((v_ticket_record->>'ticket_id')::uuid, gen_random_uuid()),
        a.attendee_id,
        (p_registration_data->>'eventId')::uuid,
        v_registration_id,
        (v_ticket_record->>'ticketTypeId')::uuid,
        v_event_ticket_price,
        v_event_ticket_price,
        COALESCE((v_ticket_record->>'price')::numeric, v_event_ticket_price),
        'reserved',
        'reserved',
        'unpaid',
        false,
        CASE 
          WHEN (v_ticket_record->>'isFromPackage')::boolean 
          THEN (v_ticket_record->>'packageId')::uuid 
        END
      FROM attendees a
      WHERE a.attendee_id = v_attendee_id
        AND a.registration_id = v_registration_id;
    END;
  END LOOP;

  -- Return success with registration details
  RETURN jsonb_build_object(
    'success', true,
    'registrationId', v_registration_id,
    'confirmationNumber', v_confirmation_number,
    'contactId', COALESCE(v_primary_attendee_contact_id, v_booking_contact_id)
  );

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Failed to process individual registration: %', SQLERRM;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.upsert_individual_registration(jsonb) TO authenticated;

-- Create comprehensive view for individual registration details
-- This view returns ALL data that the upsert_individual_registration RPC creates/updates
CREATE OR REPLACE VIEW public.individuals_registration_complete_view AS
SELECT 
  -- Registration core data
  r.registration_id,
  r.function_id,
  r.auth_user_id,
  r.contact_id,
  r.confirmation_number,
  r.registration_date,
  r.registration_type,
  r.status as registration_status,
  r.payment_status,
  r.total_amount_paid,
  r.total_price_paid,
  r.subtotal,
  r.stripe_fee,
  r.includes_processing_fee,
  r.stripe_payment_intent_id,
  r.agree_to_terms,
  r.primary_attendee_id,
  r.created_at as registration_created_at,
  r.updated_at as registration_updated_at,
  
  -- Function details
  f.name as function_name,
  f.slug as function_slug,
  f.start_date as function_start_date,
  f.end_date as function_end_date,
  
  -- Booking contact details (from contacts table)
  bc.contact_id as booking_contact_id,
  bc.auth_user_id as booking_auth_user_id,
  bc.first_name as booking_first_name,
  bc.last_name as booking_last_name,
  bc.email as booking_email,
  bc.mobile_number as booking_phone,
  bc.billing_email,
  bc.billing_phone,
  bc.billing_street_address,
  bc.billing_city,
  bc.billing_state,
  bc.billing_postal_code,
  bc.billing_country,
  bc.billing_organisation_name,
  bc.address_line_1,
  bc.address_line_2,
  bc.suburb_city,
  bc.state,
  bc.postcode,
  bc.country,
  bc.created_at as booking_contact_created_at,
  
  -- All attendees with their contacts and masonic profiles
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        -- Attendee data
        'attendee_id', a.attendee_id,
        'is_primary', a.is_primary,
        'attendee_type', a.attendee_type,
        'first_name', a.first_name,
        'last_name', a.last_name,
        'email', a.email,
        'phone', a.phone,
        'title', a.title,
        'suffix', a.suffix,
        'has_partner', a.has_partner,
        'is_partner', a.is_partner,
        'contact_preference', a.contact_preference,
        'dietary_requirements', a.dietary_requirements,
        'special_needs', a.special_needs,
        'related_attendee_id', a.related_attendee_id,
        
        -- Contact data
        'contact_id', ac.contact_id,
        'contact_auth_user_id', ac.auth_user_id,
        'contact_email', ac.email,
        'contact_first_name', ac.first_name,
        'contact_last_name', ac.last_name,
        'contact_mobile', ac.mobile_number,
        'contact_title', ac.title,
        'contact_type', ac.type,
        'contact_created_at', ac.created_at,
        
        -- Masonic profile data (if exists)
        'masonic_profile', CASE 
          WHEN mp.masonic_profile_id IS NOT NULL THEN 
            jsonb_build_object(
              'masonic_profile_id', mp.masonic_profile_id,
              'masonic_title', mp.masonic_title,
              'rank', mp.rank,
              'grand_rank', mp.grand_rank,
              'grand_officer', mp.grand_officer,
              'grand_office', mp.grand_office,
              'lodge_id', mp.lodge_id,
              'lodge_name', l.name,
              'lodge_number', l.number,
              'grand_lodge_id', mp.grand_lodge_id,
              'grand_lodge_name', gl.name
            )
          ELSE NULL
        END,
        
        -- Tickets for this attendee
        'tickets', (
          SELECT json_agg(
            jsonb_build_object(
              'ticket_id', t.ticket_id,
              'event_id', t.event_id,
              'event_title', e.title,
              'event_date', e.event_start,
              'ticket_type_id', t.ticket_type_id,
              'ticket_price', t.ticket_price,
              'original_price', t.original_price,
              'price_paid', t.price_paid,
              'status', t.status,
              'ticket_status', t.ticket_status,
              'payment_status', t.payment_status,
              'is_partner_ticket', t.is_partner_ticket,
              'package_id', t.package_id,
              'purchased_at', t.purchased_at,
              'qr_code_url', t.qr_code_url,
              'created_at', t.created_at,
              'updated_at', t.updated_at
            )
          )
          FROM tickets t
          JOIN events e ON t.event_id = e.event_id
          WHERE t.attendee_id = a.attendee_id
            AND t.registration_id = r.registration_id
        )
      )
    ) FILTER (WHERE a.attendee_id IS NOT NULL),
    '[]'::json
  ) as attendees,
  
  -- Summary counts
  COUNT(DISTINCT a.attendee_id) as total_attendees,
  COUNT(DISTINCT CASE WHEN a.attendee_type = 'mason' THEN a.attendee_id END) as total_masons,
  COUNT(DISTINCT CASE WHEN a.attendee_type = 'guest' THEN a.attendee_id END) as total_guests,
  COUNT(DISTINCT t.ticket_id) as total_tickets,
  COUNT(DISTINCT CASE WHEN t.status = 'sold' THEN t.ticket_id END) as total_sold_tickets,
  COUNT(DISTINCT CASE WHEN t.status = 'reserved' THEN t.ticket_id END) as total_reserved_tickets

FROM registrations r
LEFT JOIN functions f ON r.function_id = f.function_id
LEFT JOIN contacts bc ON r.contact_id = bc.contact_id
LEFT JOIN attendees a ON r.registration_id = a.registration_id
LEFT JOIN contacts ac ON a.contact_id = ac.contact_id
LEFT JOIN masonic_profiles mp ON ac.contact_id = mp.contact_id
LEFT JOIN lodges l ON mp.lodge_id = l.lodge_id
LEFT JOIN grand_lodges gl ON mp.grand_lodge_id = gl.grand_lodge_id
LEFT JOIN tickets t ON a.attendee_id = t.attendee_id AND r.registration_id = t.registration_id
WHERE r.registration_type = 'individuals'
GROUP BY 
  r.registration_id,
  f.function_id,
  bc.contact_id;

-- Grant appropriate permissions
GRANT SELECT ON public.individuals_registration_complete_view TO authenticated;
GRANT SELECT ON public.individuals_registration_complete_view TO anon;

-- Add helpful comment
COMMENT ON VIEW public.individuals_registration_complete_view IS 
'Comprehensive view showing all data created/updated by upsert_individual_registration RPC including registrations, contacts, attendees, masonic profiles, and tickets';