-- Fix individual registration RPC to accept new parameter structure
-- This updates the function to match what the API is calling

-- Drop the existing function first
DROP FUNCTION IF EXISTS public.upsert_individual_registration(jsonb);

-- Create the new version with proper parameters
CREATE OR REPLACE FUNCTION public.upsert_individual_registration(
    p_function_id uuid,
    p_attendees jsonb,
    p_selected_tickets jsonb,
    p_booking_contact jsonb,
    p_payment_status text,
    p_stripe_payment_intent_id text DEFAULT NULL,
    p_registration_id uuid DEFAULT NULL,
    p_total_amount numeric DEFAULT 0,
    p_subtotal numeric DEFAULT 0,
    p_stripe_fee numeric DEFAULT 0,
    p_metadata jsonb DEFAULT '{}'::jsonb
) RETURNS jsonb AS $$
DECLARE
    v_registration_id uuid;
    v_booking_contact_id uuid;
    v_customer_id uuid;
    v_primary_attendee_id uuid;
    v_attendee_id uuid;
    v_contact_id uuid;
    v_attendee jsonb;
    v_ticket jsonb;
    v_confirmation_number text;
    v_result jsonb;
    v_attendee_type text;
    v_contact_preference text;
    v_attendee_email text;
    v_attendee_phone text;
    v_total_attendees int := 0;
    v_total_tickets int := 0;
    v_attendee_index int;
BEGIN
    -- Get authenticated user
    v_customer_id := auth.uid();
    
    IF v_customer_id IS NULL THEN
        RAISE EXCEPTION 'Authentication required';
    END IF;
    
    -- Use provided registration ID or generate new one
    v_registration_id := COALESCE(p_registration_id, gen_random_uuid());
    
    -- Check if updating existing registration (payment completion)
    IF p_registration_id IS NOT NULL AND EXISTS (
        SELECT 1 FROM registrations 
        WHERE registration_id = p_registration_id 
        AND auth_user_id = v_customer_id
    ) THEN
        -- Update existing registration
        UPDATE registrations SET
            payment_status = p_payment_status::payment_status,
            stripe_payment_intent_id = p_stripe_payment_intent_id,
            total_amount_paid = p_total_amount,
            subtotal = p_subtotal,
            stripe_fee = p_stripe_fee,
            updated_at = CURRENT_TIMESTAMP
        WHERE registration_id = p_registration_id
        AND auth_user_id = v_customer_id;
        
        -- Get existing confirmation number and counts
        SELECT confirmation_number, 
               (SELECT COUNT(*) FROM attendees WHERE registration_id = p_registration_id),
               (SELECT COUNT(*) FROM tickets WHERE registration_id = p_registration_id)
        INTO v_confirmation_number, v_total_attendees, v_total_tickets
        FROM registrations
        WHERE registration_id = p_registration_id;
        
        -- Return result
        RETURN jsonb_build_object(
            'registration_id', p_registration_id,
            'confirmation_number', v_confirmation_number,
            'contact_id', v_booking_contact_id,
            'total_attendees', v_total_attendees,
            'total_tickets', v_total_tickets,
            'status', 'success'
        );
    END IF;
    
    -- Create new registration
    
    -- Generate confirmation number
    SELECT 'IND-' || 
           EXTRACT(YEAR FROM CURRENT_DATE)::text || 
           '-' || 
           LPAD(EXTRACT(MONTH FROM CURRENT_DATE)::text, 2, '0') ||
           LPAD(EXTRACT(DAY FROM CURRENT_DATE)::text, 2, '0') ||
           '-' ||
           LPAD((EXTRACT(EPOCH FROM CURRENT_TIME)::bigint % 100000)::text, 5, '0')
    INTO v_confirmation_number;
    
    -- Create booking contact
    v_booking_contact_id := gen_random_uuid();
    
    INSERT INTO customers (
        customer_id,
        title,
        first_name,
        last_name,
        email,
        mobile_number,
        phone_number,
        address_line_1,
        address_line_2,
        city,
        state_province,
        postal_code,
        country,
        type,
        source,
        created_at,
        updated_at
    ) VALUES (
        v_booking_contact_id,
        p_booking_contact->>'title',
        p_booking_contact->>'firstName',
        p_booking_contact->>'lastName',
        p_booking_contact->>'email',
        p_booking_contact->>'phone',
        p_booking_contact->>'phone',
        p_booking_contact->>'addressLine1',
        p_booking_contact->>'addressLine2',
        p_booking_contact->>'city',
        p_booking_contact->>'stateProvince',
        p_booking_contact->>'postalCode',
        p_booking_contact->>'country',
        'booking_contact',
        'individual_registration',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    );
    
    -- Create registration
    INSERT INTO registrations (
        registration_id,
        function_id,
        auth_user_id,
        registration_type,
        booking_contact_id,
        payment_status,
        stripe_payment_intent_id,
        total_amount_paid,
        subtotal,
        stripe_fee,
        confirmation_number,
        metadata,
        created_at,
        updated_at
    ) VALUES (
        v_registration_id,
        p_function_id,
        v_customer_id,
        'individuals',
        v_booking_contact_id,
        p_payment_status::payment_status,
        p_stripe_payment_intent_id,
        p_total_amount,
        p_subtotal,
        p_stripe_fee,
        v_confirmation_number,
        p_metadata,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    );
    
    -- Process attendees
    v_attendee_index := 0;
    FOR v_attendee IN SELECT * FROM jsonb_array_elements(p_attendees)
    LOOP
        v_attendee_id := gen_random_uuid();
        
        -- Convert attendeeType to lowercase for enum compatibility
        v_attendee_type := LOWER(COALESCE(v_attendee->>'attendeeType', 'guest'));
        v_contact_preference := COALESCE(v_attendee->>'contactPreference', 'directly');
        
        -- Extract contact info
        v_attendee_email := COALESCE(
            v_attendee->>'email',
            v_attendee->>'primaryEmail'
        );
        
        v_attendee_phone := COALESCE(
            v_attendee->>'phone',
            v_attendee->>'primaryPhone',
            v_attendee->>'mobileNumber'
        );
        
        -- Track primary attendee
        IF v_attendee_index = 0 THEN
            v_primary_attendee_id := v_attendee_id;
        END IF;
        
        -- Insert attendee
        INSERT INTO attendees (
            attendee_id,
            registration_id,
            attendee_type,
            is_primary,
            related_attendee_id,
            first_name,
            last_name,
            title,
            suffix_1,
            suffix_2,
            suffix_3,
            dietary_requirements,
            special_needs,
            contact_preference,
            primary_email,
            primary_phone,
            attendee_data,
            created_at,
            updated_at
        ) VALUES (
            v_attendee_id,
            v_registration_id,
            v_attendee_type::attendee_type,
            v_attendee_index = 0,
            CASE 
                WHEN (v_attendee->>'isPartner')::text IS NOT NULL AND (v_attendee->>'isPartner')::text != 'null' 
                THEN (v_attendee->>'isPartner')::uuid 
                ELSE NULL 
            END,
            v_attendee->>'firstName',
            v_attendee->>'lastName',
            v_attendee->>'title',
            v_attendee->>'postNominals',
            v_attendee->>'suffix2',
            v_attendee->>'suffix3',
            v_attendee->>'dietaryRequirements',
            v_attendee->>'specialNeeds',
            v_contact_preference::attendee_contact_preference,
            v_attendee_email,
            v_attendee_phone,
            v_attendee,
            CURRENT_TIMESTAMP,
            CURRENT_TIMESTAMP
        );
        
        -- Create contact record if needed
        IF v_contact_preference = 'directly' AND (v_attendee_email IS NOT NULL OR v_attendee_phone IS NOT NULL) THEN
            v_contact_id := gen_random_uuid();
            
            INSERT INTO contacts (
                contact_id,
                type,
                first_name,
                last_name,
                email,
                mobile_number,
                title,
                suffix_1,
                suffix_2,
                suffix_3,
                dietary_requirements,
                special_needs,
                contact_preference,
                has_partner,
                is_partner,
                source_id,
                source_type,
                created_at,
                updated_at
            ) VALUES (
                v_contact_id,
                'attendee',
                v_attendee->>'firstName',
                v_attendee->>'lastName',
                COALESCE(v_attendee_email, ''),
                v_attendee_phone,
                v_attendee->>'title',
                v_attendee->>'postNominals',
                v_attendee->>'suffix2',
                v_attendee->>'suffix3',
                v_attendee->>'dietaryRequirements',
                v_attendee->>'specialNeeds',
                v_contact_preference,
                CASE WHEN (v_attendee->>'partner')::text IS NOT NULL THEN true ELSE false END,
                CASE WHEN (v_attendee->>'isPartner')::text IS NOT NULL THEN true ELSE false END,
                v_attendee_id,
                'attendee',
                CURRENT_TIMESTAMP,
                CURRENT_TIMESTAMP
            );
        END IF;
        
        v_attendee_index := v_attendee_index + 1;
        v_total_attendees := v_total_attendees + 1;
    END LOOP;
    
    -- Process tickets
    FOR v_ticket IN SELECT * FROM jsonb_array_elements(p_selected_tickets)
    LOOP
        -- Create ticket for each attendee who has this ticket
        FOR v_attendee_id IN 
            SELECT (jsonb_array_elements_text(v_ticket->'attendeeIds'))::uuid
        LOOP
            INSERT INTO tickets (
                ticket_id,
                registration_id,
                attendee_id,
                event_id,
                ticket_definition_id,
                status,
                created_at,
                updated_at
            ) VALUES (
                gen_random_uuid(),
                v_registration_id,
                v_attendee_id,
                (v_ticket->>'eventId')::uuid,
                (v_ticket->>'ticketDefinitionId')::uuid,
                'confirmed',
                CURRENT_TIMESTAMP,
                CURRENT_TIMESTAMP
            );
            
            v_total_tickets := v_total_tickets + 1;
        END LOOP;
    END LOOP;
    
    -- Return result
    RETURN jsonb_build_object(
        'registration_id', v_registration_id,
        'confirmation_number', v_confirmation_number,
        'contact_id', v_booking_contact_id,
        'total_attendees', v_total_attendees,
        'total_tickets', v_total_tickets,
        'status', 'success'
    );
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log error and re-raise
        RAISE NOTICE 'Error in upsert_individual_registration: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.upsert_individual_registration(uuid, jsonb, jsonb, jsonb, text, text, uuid, numeric, numeric, numeric, jsonb) TO authenticated;
GRANT EXECUTE ON FUNCTION public.upsert_individual_registration(uuid, jsonb, jsonb, jsonb, text, text, uuid, numeric, numeric, numeric, jsonb) TO anon;